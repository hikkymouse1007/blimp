package syncthing

import (
	"context"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"time"

	rice "github.com/GeertJohan/go.rice"
	log "github.com/sirupsen/logrus"
	"github.com/syncthing/syncthing/lib/fs"
	"github.com/syncthing/syncthing/lib/ignore"

	"github.com/kelda-inc/blimp/pkg/cfgdir"
	"github.com/kelda-inc/blimp/pkg/errors"
	"github.com/kelda-inc/blimp/pkg/hash"
	"github.com/kelda-inc/blimp/pkg/proto/node"
)

const stignoreHeader = "# Generated by Blimp. DO NOT EDIT."

type Client struct {
	mounts  []Mount
	volumes []string
}

func (c Client) GetIDPathMap() map[string]string {
	idPathMap := map[string]string{}
	for _, m := range c.mounts {
		idPathMap[m.ID()] = m.Path
	}
	return idPathMap
}

type Mount struct {
	Path    string
	Include []string
	SyncAll bool
}

func (m Mount) GetStignore() (stignore string, needed bool) {
	if m.SyncAll {
		return "", false
	}

	stignore = stignoreHeader + "\n"
	stignore += `# This file is used by Blimp to control what files are synced.

# Only sync the following files:
`
	for _, include := range m.Include {
		stignore += fmt.Sprintf("!/%s\n", include)
	}
	stignore += `
# Ignore all other files.
**
`

	return stignore, true
}

func (m Mount) ID() string {
	return hash.DnsCompliant(m.Path)
}

func NewClient(volumes []string) Client {
	var allMounts []Mount
	// Collect all the mounts, regardless of whether they're nested.
	for _, volume := range volumes {
		// For directories, we just mount the entire directory. For other
		// files, we mount the parent directory, and use .stignore to only sync
		// the desired files.
		if isDir(volume) {
			allMounts = append(allMounts, Mount{
				Path:    volume,
				SyncAll: true,
			})
		} else {
			allMounts = append(allMounts, Mount{
				Path:    filepath.Dir(volume),
				Include: []string{filepath.Base(volume)},
			})
		}
	}

	// Collapse nested mounts to avoid confusing Syncthing.
	// We first sort the mounts from shallowest to deepest. This way, we know
	// that the first mount that matches a path is the most efficient match.
	sort.Slice(allMounts, func(i, j int) bool {
		depth := func(path string) int {
			return strings.Count(path, string(filepath.Separator))
		}
		return depth(allMounts[i].Path) < depth(allMounts[j].Path)
	})

	// Starting from the highest-level directories, try to greedily combine
	// child mounts.
	var collapsedMounts []Mount
	// skipIndices tracks mounts that have been collapsed already.
	skipIndices := map[int]struct{}{}
	for pi, parent := range allMounts {
		if _, ok := skipIndices[pi]; ok {
			continue
		}

		for mi := pi + 1; mi < len(allMounts); mi++ {
			if _, ok := skipIndices[mi]; ok {
				continue
			}

			mount := allMounts[mi]
			relPath, ok := getSubpath(parent.Path, mount.Path)
			if !ok {
				// The mount isn't nested within the parent.
				continue
			}

			switch {
			// If we're syncing over the entire directory, then any includes for
			// files don't matter since they'll be automatically picked up.
			case parent.SyncAll:
				// Don't need to do anything.

			// If we're syncing an entire subdirectory, add the relative
			// path to the subdirectory to the include list.
			case mount.SyncAll:
				// If it's the same path, then just modify the parent to sync
				// all the files.
				if relPath == "." {
					parent.SyncAll = true
					parent.Include = nil
				} else {
					// Otherwise, add the relative path to the subdirectory to the
					// include list.
					parent.Include = append(parent.Include, relPath)
				}

			// If we're syncing an individual file, add the individual file to
			// the include list.
			default:
				for _, include := range mount.Include {
					parent.Include = append(parent.Include, filepath.Join(relPath, include))
				}
			}
			skipIndices[mi] = struct{}{}
		}

		collapsedMounts = append(collapsedMounts, parent)
	}

	return Client{
		mounts:  collapsedMounts,
		volumes: volumes,
	}
}

func (c Client) Run(ctx context.Context, ncc node.ControllerClient, token string, finishedInitialSync <-chan struct{}) ([]byte, error) {
	box := rice.MustFindBox("stbin")

	idPathMap := c.GetIDPathMap()
	err := MakeMarkers(idPathMap)
	if err != nil {
		return nil, errors.WithContext("make markers", err)
	}

	for _, m := range c.mounts {
		// Remove any stale stignores. This avoids an issue where a previous
		// run mounts a file in a directory, which creates an stignore, and the
		// user modifies their volumes to mount the entire directory.
		// In that case, we should run with no stignore at all.
		if contents, err := ioutil.ReadFile(".stignore"); err == nil {
			if strings.Contains(string(contents), stignoreHeader) {
				if err := os.Remove(".stignore"); err != nil {
					return nil, errors.WithContext("remove stignore", err)
				}
			}
		}

		stignore, ok := m.GetStignore()
		if !ok {
			continue
		}

		path := filepath.Join(m.Path, ".stignore")
		err := ioutil.WriteFile(path, []byte(stignore), 0644)
		if err != nil {
			return nil, errors.WithContext("write stignore", err)
		}

		go ensureFileExists(path, stignore)
	}

	go c.syncFileHash(ncc, token, finishedInitialSync)

	stbinBytes, err := box.Bytes("")
	if err != nil {
		// This really really can't happen as stbin is supposed to be
		// literally embedded in this binary.  A panic is actually
		// appropriate.
		panic(err)
	}

	stbinPath := cfgdir.Expand("stbin")
	err = ioutil.WriteFile(stbinPath, stbinBytes, 0755)
	if err != nil {
		return nil, errors.WithContext("write stbin error", err)
	}

	fileMap := map[string]string{
		"config.xml": makeConfig(false, idPathMap),
		"cert.pem":   cert,
		"key.pem":    key,
	}

	for path, data := range fileMap {
		err := ioutil.WriteFile(cfgdir.Expand(path), []byte(data), 0666)
		if err != nil {
			return nil, errors.WithContext("write config file error", err)
		}
	}

	return exec.CommandContext(ctx, stbinPath, "-verbose", "-home", cfgdir.Expand(""),
		"-logfile", cfgdir.Expand("syncthing.log")).CombinedOutput()
}

func (c Client) syncFileHash(ncc node.ControllerClient, token string, stop <-chan struct{}) {
	isIgnored := c.GetIsIgnored()
	sendOnce := func() {
		hashes := map[string]string{}
		for _, volume := range c.volumes {
			h, err := HashVolume(volume, isIgnored)
			if err != nil {
				log.WithError(err).Warn("Failed to calculate bind volume hash")
				return
			}

			hashes[volume] = h
		}

		_, err := ncc.UpdateVolumeHashes(context.Background(), &node.UpdateVolumeHashesRequest{
			Token:  token,
			Hashes: hashes,
		})
		if err != nil {
			log.WithError(err).Warn("Failed to send hash update")
			return
		}
	}

	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()
	for {
		sendOnce()

		select {
		case <-stop:
			return
		case <-ticker.C:
		}
	}
}

func (c Client) GetIsIgnored() func(string) bool {
	mountToIgnorer := map[string]*ignore.Matcher{}
	for _, m := range c.mounts {
		ignoreMatcher := ignore.New(fs.NewFilesystem(fs.FilesystemTypeBasic, ""))
		ignorePath := filepath.Join(m.Path, ".stignore")
		if _, err := os.Stat(ignorePath); err != nil {
			continue
		}

		if err := ignoreMatcher.Load(ignorePath); err != nil {
			log.WithError(err).WithField("path", ignorePath).Warn("Ignoring malformed stignore")
			continue
		}
		mountToIgnorer[m.Path] = ignoreMatcher
	}

	return func(path string) bool {
		for mount, ignorer := range mountToIgnorer {
			subpath, ok := getSubpath(mount, path)
			if !ok {
				continue
			}

			if ignorer.ShouldIgnore(subpath) {
				return true
			}
		}
		return false
	}
}

func ensureFileExists(path, contents string) {
	for {
		err := ioutil.WriteFile(path, []byte(contents), 0644)
		if err != nil {
			log.WithField("path", path).WithError(err).Warn("Failed to write file")
		}
		time.Sleep(30 * time.Second)
	}
}

var isDir = func(path string) bool {
	fi, err := os.Stat(path)

	// Create the path as a directory if it doesn't exist.
	if os.IsNotExist(err) {
		if err := os.MkdirAll(path, 0755); err != nil {
			log.
				WithError(err).
				WithField("path", path).
				Fatal("Tried to create directory for non-existent bind volume, but failed")
		}
		return true
	}

	return err == nil && fi.IsDir()
}

func getSubpath(parent, child string) (string, bool) {
	relPath, err := filepath.Rel(parent, child)
	if err != nil || strings.HasPrefix(relPath, "..") {
		return "", false
	}
	return relPath, true
}
