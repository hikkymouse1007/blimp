package syncthing

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/syncthing/syncthing/lib/fs"
	"github.com/syncthing/syncthing/lib/ignore"
)

func TestCalculateMounts(t *testing.T) {
	tests := []struct {
		name    string
		dirs    []string
		volumes []string
		exp     []Mount
	}{
		{
			name: "Sync directory",
			volumes: []string{
				"/Users/kevin/kelda.io",
			},
			dirs: []string{
				"/Users/kevin/kelda.io",
			},
			exp: []Mount{
				{
					Path:    "/Users/kevin/kelda.io",
					SyncAll: true,
				},
			},
		},
		{
			name: "Sync two files in same dir",
			volumes: []string{
				"/Users/kevin/kelda.io/file-1",
				"/Users/kevin/kelda.io/file-2",
			},
			dirs: []string{
				"/Users/kevin/kelda.io",
			},
			exp: []Mount{
				{
					Path: "/Users/kevin/kelda.io",
					Include: []string{
						"file-1",
						"file-2",
					},
				},
			},
		},
		{
			name: "Sync two files in same dir and parent dir",
			volumes: []string{
				"/Users/kevin/kelda.io",
				"/Users/kevin/kelda.io/file-1",
				"/Users/kevin/kelda.io/file-2",
			},
			dirs: []string{
				"/Users/kevin/kelda.io",
			},
			exp: []Mount{
				{
					Path:    "/Users/kevin/kelda.io",
					SyncAll: true,
				},
			},
		},
		{
			name: "Nested syncs",
			volumes: []string{
				"/Users/kevin/kelda.io",
				"/Users/kevin/kelda.io/files",
				"/Users/kevin/kelda.io/files/file-1",
				"/Users/kevin/kelda.io/files/file-2",
			},
			dirs: []string{
				"/Users/kevin/kelda.io",
				"/Users/kevin/kelda.io/files",
			},
			exp: []Mount{
				{
					Path:    "/Users/kevin/kelda.io",
					SyncAll: true,
				},
			},
		},
		{
			name: "Nested syncs with top-level file",
			volumes: []string{
				"/Users/kevin/kelda.io/top-level",
				"/Users/kevin/kelda.io/files/subdir",
			},
			dirs: []string{
				"/Users/kevin/kelda.io",
				"/Users/kevin/kelda.io/files",
				"/Users/kevin/kelda.io/files/subdir",
			},
			exp: []Mount{
				{
					Path: "/Users/kevin/kelda.io",
					Include: []string{
						"top-level",
						"files/subdir",
					},
				},
			},
		},
		{
			name: "Top level file sync with nested dir sync",
			volumes: []string{
				"/Users/kevin/kelda.io/file-1",
				"/Users/kevin/kelda.io/dir",
			},
			dirs: []string{
				"/Users/kevin/kelda.io",
				"/Users/kevin/kelda.io/dir",
			},
			exp: []Mount{
				{
					Path: "/Users/kevin/kelda.io",
					Include: []string{
						"file-1",
						"dir",
					},
				},
			},
		},
		{
			name: "Syncing entire directory and nested file, with the file coming first",
			volumes: []string{
				"/Users/kevin/kelda.io/file-1",
				"/Users/kevin/kelda.io",
			},
			dirs: []string{
				"/Users/kevin/kelda.io",
			},
			exp: []Mount{
				{
					Path:    "/Users/kevin/kelda.io",
					SyncAll: true,
				},
			},
		},
	}

	for _, test := range tests {
		test := test
		t.Run(test.name, func(t *testing.T) {
			isDir = func(path string) bool {
				for _, dir := range test.dirs {
					if filepath.Clean(path) == filepath.Clean(dir) {
						return true
					}
				}
				return false
			}

			actual := NewClient(test.volumes)
			assert.Equal(t, test.exp, actual.mounts)
		})
	}
}

func TestGetStginore(t *testing.T) {
	tests := []struct {
		name            string
		mount           Mount
		expStignore     string
		expNeeded       bool
		shouldIgnore    []string
		shouldNotIgnore []string
	}{
		{
			name: "No includes",
			mount: Mount{
				Path:    "/Users/kevin/kelda.io",
				SyncAll: true,
			},
			expStignore: "",
			expNeeded:   false,
			shouldNotIgnore: []string{
				"all",
				"files/should",
				"be/synced",
			},
		},
		{
			name: "Subdirectory",
			mount: Mount{
				Path: "/Users/kevin/kelda.io",
				Include: []string{
					"files/subdir",
				},
			},
			expStignore: `# Generated by Blimp. DO NOT EDIT.
# This file is used by Blimp to control what files are synced.

!/files/subdir
/files/
!/files

# Ignore all other files.
**
`,
			expNeeded: true,
			shouldIgnore: []string{
				"other-files",
				"and/other/dirs",
				"dir",
				"files/other-subdir",
			},
			shouldNotIgnore: []string{
				"files/subdir",
				"files/subdir/file",
				"files/subdir/anotherdir",
				"files/subdir/anotherdir/file",
			},
		},
		{
			name: "Multiple sibling subdirectories",
			mount: Mount{
				Path: "/Users/kevin/kelda.io",
				Include: []string{
					"files/subdir1",
					"files/subdir2",
				},
			},
			expStignore: `# Generated by Blimp. DO NOT EDIT.
# This file is used by Blimp to control what files are synced.

!/files/subdir1
!/files/subdir2
/files/
!/files

# Ignore all other files.
**
`,
			expNeeded: true,
			shouldIgnore: []string{
				"other-files",
				"and/other/dirs",
				"dir",
				"files/other-subdir",
			},
			shouldNotIgnore: []string{
				"files/subdir1",
				"files/subdir1/file",
				"files/subdir1/anotherdir",
				"files/subdir1/anotherdir/file",
				"files/subdir2",
				"files/subdir2/file",
				"files/subdir2/anotherdir",
				"files/subdir2/anotherdir/file",
			},
		},
	}

	for _, test := range tests {
		test := test
		t.Run(test.name, func(t *testing.T) {
			stignore, needed := test.mount.GetStignore()
			assert.Equal(t, test.expStignore, stignore)
			assert.Equal(t, test.expNeeded, needed)

			// We need to write the test files to disk so that the Syncthing
			// ignore library can see them.
			testDir, err := ioutil.TempDir("", "stignore-test")
			require.NoError(t, err)
			defer os.RemoveAll(testDir)

			stignorePath := filepath.Join(testDir, ".stignore")
			require.NoError(t, ioutil.WriteFile(stignorePath, []byte(stignore), 0644))

			ignoreMatcher := ignore.New(fs.NewFilesystem(fs.FilesystemTypeBasic, ""))
			require.NoError(t, ignoreMatcher.Load(stignorePath))

			for _, path := range test.shouldIgnore {
				assert.True(t, ignoreMatcher.ShouldIgnore(path), fmt.Sprintf("should ignore %q", path))
			}

			for _, path := range test.shouldNotIgnore {
				assert.False(t, ignoreMatcher.ShouldIgnore(path), fmt.Sprintf("should not ignore %q", path))
			}
		})
	}
}
