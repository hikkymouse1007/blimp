package main

import (
	"sync"
	"time"

	log "github.com/sirupsen/logrus"
	corev1 "k8s.io/api/core/v1"
	meta "k8s.io/apimachinery/pkg/api/meta"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/informers"
	"k8s.io/client-go/kubernetes"
	listers "k8s.io/client-go/listers/core/v1"
	"k8s.io/client-go/tools/cache"

	"github.com/kelda-inc/blimp/pkg/proto/cluster"
)

// statusFetcher provides an API for getting the status of namespaces, and
// subscribing to changes to namespaces.
// It caches pod statuses.
type statusFetcher struct {
	informer cache.SharedIndexInformer
	lister   listers.PodLister

	// A map from namespace to a map of clients that are watching the
	// namespace.
	// Each client is identified by an ID, which is generated by `idCtr`. This
	// ID is used for terminating watches.
	watchers     map[string]map[int]chan struct{}
	watchersLock sync.Mutex

	idCtr  int
	idLock sync.Mutex
}

func newStatusFetcher(kubeClient kubernetes.Interface) *statusFetcher {
	factory := informers.NewSharedInformerFactory(kubeClient, 30*time.Second)
	informer := factory.Core().V1().Pods()

	sf := &statusFetcher{
		informer: informer.Informer(),
		lister:   informer.Lister(),
		watchers: map[string]map[int]chan struct{}{},
	}

	sf.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc:    sf.notifyWatchers,
		DeleteFunc: sf.notifyWatchers,
		UpdateFunc: func(_, intf interface{}) {
			sf.notifyWatchers(intf)
		},
	})

	return sf
}

func (sf *statusFetcher) Start() {
	go sf.informer.Run(nil)
	cache.WaitForCacheSync(nil, sf.informer.HasSynced)
}

func (sf *statusFetcher) Watch(namespace string) (notifier chan struct{}, stop chan struct{}) {
	sf.idLock.Lock()
	sf.idCtr++
	id := sf.idCtr
	sf.idLock.Unlock()

	sf.watchersLock.Lock()
	defer sf.watchersLock.Unlock()

	watchers, ok := sf.watchers[namespace]
	if !ok {
		watchers = map[int]chan struct{}{}
		sf.watchers[namespace] = watchers
	}

	notifier = make(chan struct{}, 1)
	watchers[id] = notifier

	stop = make(chan struct{})
	go func() {
		<-stop
		sf.removeWatcher(namespace, id)
	}()

	return notifier, stop
}

func (sf *statusFetcher) notifyWatchers(intf interface{}) {
	obj, ok := intf.(runtime.Object)
	if !ok {
		log.WithField("obj", obj).
			Warn("Unexpected non-runtime.Object type")
		return
	}

	namespace, err := meta.NewAccessor().Namespace(obj)
	if err != nil {
		log.WithError(err).
			WithField("obj", obj).
			Warn("Failed to get namespace for object")
		return
	}

	// Send notifications to all watchers.
	sf.watchersLock.Lock()
	defer sf.watchersLock.Unlock()
	for _, client := range sf.watchers[namespace] {
		select {
		case client <- struct{}{}:
		default:
		}
	}
}

func (sf *statusFetcher) removeWatcher(namespace string, id int) {
	sf.watchersLock.Lock()
	defer sf.watchersLock.Unlock()

	watchers, ok := sf.watchers[namespace]
	if !ok {
		log.WithField("namespace", namespace).
			WithField("id", id).
			Warn("Failed to look up watcher for deletion. " +
				"This shouldn't happen unless there's a race, or the watcher ID counter overflowed.")
		return
	}

	delete(watchers, id)
	if len(watchers) == 0 {
		delete(sf.watchers, namespace)
	}
}

func (sf *statusFetcher) Get(namespace string) (cluster.SandboxStatus, error) {
	pods, err := sf.lister.
		Pods(namespace).
		List(labels.Set(
			map[string]string{"blimp.customerPod": "true"},
		).AsSelector())
	if err != nil {
		return cluster.SandboxStatus{}, err
	}

	services := map[string]*cluster.ServiceStatus{}
	for _, pod := range pods {
		services[pod.Name] = &cluster.ServiceStatus{Phase: getServicePhase(pod)}
	}
	return cluster.SandboxStatus{Services: services}, nil
}

func getServicePhase(pod *corev1.Pod) string {
	for _, c := range pod.Status.InitContainerStatuses {
		if c.State.Running != nil {
			switch c.Name {
			case ContainerNameCopyBusybox, ContainerNameCopyVCP, ContainerNameInitializeVolumeFromImage:
				return "Initializing volumes"
			case ContainerNameWaitDependsOn:
				return "Waiting for dependencies to boot"
			case ContainerNameWaitInitialSync:
				return "Syncing volumes. See progress at http://localhost:8834"
			default:
				return "Waiting for service to initialize"
			}
		}
	}

	phase := string(pod.Status.Phase)
	if len(pod.Status.ContainerStatuses) == 1 {
		containerStatus := pod.Status.ContainerStatuses[0]
		switch {
		case containerStatus.State.Waiting != nil && containerStatus.State.Waiting.Message != "":
			phase += ": " + containerStatus.State.Waiting.Message
		case containerStatus.State.Terminated != nil && containerStatus.State.Terminated.Message != "":
			phase += ": " + containerStatus.State.Terminated.Message
		}
	}
	return phase
}
